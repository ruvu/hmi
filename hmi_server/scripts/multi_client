#!/usr/bin/env python

import rospy
from hmi_msgs.msg import QueryAction, QueryResult, Result
from actionlib import SimpleActionClient, SimpleActionServer, SimpleGoalState
from rosgraph.names import namespace


def goal_to_str(goal):
    logstr = ', '.join(['(%s)' % str(c).replace('\n', ', ') for c in goal.choices])
    return 'description: "%s", spec: "%s", choices: [%s]' % (goal.description, goal.spec, logstr)


def result_to_str(result):
    logstr = ', '.join(['(%s)' % str(r).replace('\n', ', ') for r in result.results])
    return '[%s]' % logstr


class MultiClient(object):

    def __init__(self, name, server_namespace):
        self._action_name = name
        self._server_namespace = server_namespace

        self.server = SimpleActionServer(name, QueryAction,
                                         execute_cb=self.execute_cb, auto_start=False)
        self.server.start()
        rospy.loginfo('%s started with ns: %s', name, server_namespace)

    def execute_cb(self, goal):
        rospy.loginfo('got a goal: %s', goal_to_str(goal))

        servers = self.find_servers(self._server_namespace)
        rospy.loginfo("Found %d servers: %s", len(servers), servers)
        clients = [HMIClient(ns) for ns in servers]

        # wait 0.1 second for every client
        timeout = rospy.Duration(0.1)
        clients = [client for client in clients if client.wait_for_server(timeout)]

        for client in clients:
            client.send_goal(goal)

        # wait for one server to be finished
        r = rospy.Rate(10)
        while not rospy.is_shutdown():
            # the goal could be cancelled
            if self.server.is_preempt_requested():
                rospy.loginfo('%s: Preempted' % self._action_name)
                break
            if self.one_client_done(clients):
                break
            rospy.loginfo('spinning...')
            r.sleep()

        # get the result
        result = None
        for client in clients:
            if client.is_done():
                result = client.get_result()
                break

        # cancel all the others
        for client in clients:
            if not client.is_done():
                client.cancel_goal()

        if result:
            rospy.loginfo('result: %s', result_to_str(result))
        else:
            rospy.logwarn('no result received')

        if self.server.is_preempt_requested():
            self.server.set_preempted()
        elif not result:
            self.server.set_aborted(result=None, text="No result")
        else:
            self.server.set_succeeded(result)

    def one_client_done(self, clients):
        if not len(clients):
            rospy.logerr('there are no hmi clients at this moment')
            return True

        loop_period = rospy.Duration(0.1)
        for client in clients:
            client.is_done()
            if client.wait_for_result(loop_period):
                return True
        return False

    def find_servers(self, ns):
        topics = []
        for name, topic_type in rospy.get_published_topics(ns):
            topic_ns = namespace(name)[0:-1]
            if topic_ns != self._server_namespace:
                if topic_type == 'hmi_msgs/QueryActionResult':
                    rospy.loginfo('Found topic %s', name)
                    topics.append(topic_ns)

        return topics


class HMIClient(object):

    def __init__(self, client_namespace):
        self._client_namespace = client_namespace

        self.client = SimpleActionClient(client_namespace, QueryAction)

    def send_goal(self, goal):
        rospy.loginfo('sending %s the following goal: %s',
                      self._client_namespace, goal_to_str(goal))
        self.client.send_goal(goal)

    def wait_for_result(self, timeout=rospy.Duration()):
        return self.client.wait_for_result(timeout=timeout)

    def is_done(self):
        if self.client.simple_state == SimpleGoalState.DONE:
            return True
        return False

    def cancel_goal(self):
        self.client.cancel_goal()

    def get_result(self):
        return self.client.get_result()

    def wait_for_server(self, timeout=rospy.Duration(0.0)):
        return self.client.wait_for_server(timeout=timeout)


if __name__ == '__main__':
    rospy.init_node('multi_client')

    ns = rospy.get_namespace() + 'hmi'

    MultiClient(rospy.get_name(), ns)
    rospy.spin()
